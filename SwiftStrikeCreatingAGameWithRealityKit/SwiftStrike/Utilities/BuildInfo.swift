/*
See LICENSE folder for this sampleâ€™s licensing information.

Abstract:
Convenience extension for type safe UserDefaults access.
*/

import Foundation
import os.log

extension GameLog {
    static let buildInfo = OSLog(subsystem: subsystem, category: "buildInfo")
}

/*
 Sample contents of the BuildInfo.plist
 NOTE:  one and only one of CIBuildNumber or DeveloperBuildNumber
        should be in the file
 <key>XcodeVersion</key>
 <string>12.0/string>
 <key>DeveloperBuildNumber</key>
 <integer>1</integer>
 */

//
// BuildInfo data types can be Int64 or String
// For network transport we only allow certain types to be used in our
// BuildInfoNetworkBundle because we convert them to binary for
// transport and from binary during retrieval.
enum BuildInfoTypeId: UInt32, CaseIterable {
    case int64
    case string

    fileprivate var asNSTypeString: String {
        switch self {
        case .int64: return "NSNumber (integer)"
        case .string: return "NSString (string)"
        }
    }
}
private protocol BuildInfoNetworkValueTypeProtocol {}
extension Int64: BuildInfoNetworkValueTypeProtocol {}
extension String: BuildInfoNetworkValueTypeProtocol {}

class BuildInfo {

    static let shared = BuildInfo()

    // Your CI build system should create a BuildInfo.plist to
    // replace the one in the source.  The one in the source
    // may be used by developers without a CI build system
    // to enforece the network compatibility using a build
    // number/id.
    fileprivate enum Key: UInt8, BitStreamCodable {
        case none
        // CI build system only
        case ciBuildNumber
        // Developer version control only
        case devBuildNumber
        // version control or CI build system

        private static let ciBuildNumberString = "CIBuildNumber"   // this symbol is only generated by a CI build system
        private static let devBuildNumberString = "DeveloperBuildNumber"

        case xcodeVersion

        private static let xcodeVersionString = "XcodeVersion"

        init?(fromKey key: String) {
            switch key {
            case Key.ciBuildNumberString: self = .ciBuildNumber
            case Key.devBuildNumberString: self = .devBuildNumber
            case Key.xcodeVersionString: self = .xcodeVersion
            default: return nil
            }
        }

        fileprivate var asString: String {
            switch self {
            case .ciBuildNumber: return Key.ciBuildNumberString
            case .devBuildNumber: return Key.devBuildNumberString
            case .xcodeVersion: return Key.xcodeVersionString
            default: return String(format: "<unknown BuildInfo.Key - %s>", "\(self)")
            }
        }

        fileprivate var asTypeId: BuildInfoTypeId {
            switch self {
            case .ciBuildNumber: return .int64
            case .devBuildNumber: return .int64
            case .xcodeVersion: return .string
            default: fatalError(String(format: "unknown BuildInfo.Key - %s", "\(self)"))
            }
        }

        init(from bitStream: inout ReadableBitStream) throws {
            let key = Key(rawValue: try bitStream.readUInt8())
            self = key ?? .none
        }

        func encode(to bitStream: inout WritableBitStream) {
            bitStream.appendUInt8(self.rawValue)
        }
    }

    private static let defaultDictionary: [Key: Any] = [
        Key.ciBuildNumber: 180,
        Key.devBuildNumber: 1,
        Key.xcodeVersion: "12.0"
    ]

    fileprivate var dictionary = defaultDictionary

    private init() {
        //NSDictionary does not have isEmpty...
        guard let path = Bundle.main.path(forResource: "BuildInfo", ofType: "plist"),
        let fileDictionary = NSDictionary(contentsOfFile: path),
        fileDictionary.count > 0 else {
            return
        }

        // convert NSDictionary to Dictionary
        os_log(.default, log: GameLog.buildInfo, "BuildInfo.plist:")
        dictionary = [Key: Any]()
        var error = false
        fileDictionary.forEach { nsKey, nsValue in
            guard let stringKey = nsKey as? String, let key = BuildInfo.Key(fromKey: stringKey) else {
                return
            }
            os_log(.default, log: GameLog.buildInfo, "  %@: %s", stringKey, "\(nsValue)")
            // convert to native Swift types that we have added the BuildInfoNetworkValueTypeProtocol
            // to below
            var success = false
            switch key.asTypeId {
            case .int64:
                if let nsNumber = nsValue as? NSNumber {
                    dictionary[key] = nsNumber.int64Value
                    success = true
                }
            case .string:
                if let nsString = nsValue as? NSString {
                    let valueString = String(nsString)
                    dictionary[key] = valueString
                    success = true
                    if valueString.isEmpty {
                        os_log(.error, log: GameLog.buildInfo,
                               "expected non-empty string for key %s from plist file",
                               "\(key.asString)")
                        error = true
                    }
                }
            }
            if !success {
                os_log(.error, log: GameLog.buildInfo,
                       "expected type %s for key %s from plist file, but got %s",
                       "\(key.asTypeId.asNSTypeString)", "\(key.asString)", "\(type(of: nsValue))")
                error = true
            }
        }

        if error {
            fatalError("BuildInfo: errors parsing plist file, please check log")
        }
    }

    private static func get(forKey key: Key) -> Any? {
        return shared.dictionary[key]
    }

}

extension BuildInfo {
    private static func detail(key: Key, value: String) -> String {
        switch key {
        case .devBuildNumber, .ciBuildNumber, .xcodeVersion: return key.asString + " " + value
        default: return value
        }
    }

    static var details: [String] {
        var report = [String]()
        shared.dictionary.sorted {
            return $0.key.asString < $1.key.asString
        }.forEach { (key, value) in
            let line = detail(key: key, value: "\(value)")
            report.append(line)
        }
        return report
    }

    static func logDetails() {
        os_log(.default, log: GameLog.buildInfo, "BuildInfo:")
        return details.forEach { line in
            os_log(.default, log: GameLog.buildInfo, "    %s", "\(line)")
        }
    }
}

extension BuildInfo {
    fileprivate static func getNetworkTypeForValue(forKey key: BuildInfo.Key) -> BuildInfoNetworkValueTypeProtocol? {
        guard let value = BuildInfo.get(forKey: key) else { return nil }
        return value as? BuildInfoNetworkValueTypeProtocol
    }
}

final class BuildInfoNetworkBundle {

    fileprivate struct NetworkData {
        fileprivate let valueTypeId: BuildInfoTypeId
        private let value: Any //BuildInfoNetworkValueTypeProtocol

        fileprivate init(valueTypeId: BuildInfoTypeId, value: BuildInfoNetworkValueTypeProtocol) {
            self.valueTypeId = valueTypeId
            self.value = value
        }

        fileprivate var networkValue: BuildInfoNetworkValueTypeProtocol {
            guard let returnValue = value as? BuildInfoNetworkValueTypeProtocol else {
                fatalError(String(format: "BuildInfoNetworkBundle.Data: value stored is not BuildInfoNetworkValueTypeProtocol???, is '%s'",
                                  "\(type(of: value))"))
            }
            return returnValue
        }

        static let map: [String: Int8] = [
            "": 1
        ]

        private static func networkMap(_ input: String) -> (Int8, String) {
            if let index = map.firstIndex(where: { input.hasPrefix($0.0) }) {
                let entry = map[index]
                let suffix = String(input.suffix(from: entry.0.endIndex))
                return (entry.1, suffix)
            }
            fatalError("could not map '\(input)' for network encoding")
        }

        private static func networkUnmap(value: Int8, input: String) -> String {
            if let index = map.firstIndex(where: { value == $0.1 }) {
                let entry = map[index]
                let prefix = entry.0
                return prefix + input
            }
            fatalError("could not unmap '\(value), \(input)' for network encoding")
        }

        fileprivate init(from bitStream: inout ReadableBitStream) throws {
            valueTypeId = try bitStream.readEnum()
            switch valueTypeId {
            case .int64:
                value = Int64(try bitStream.readInt64())
            case .string:
                let int8 = try bitStream.readInt8()
                let string = String(try bitStream.readString())
                value = NetworkData.networkUnmap(value: int8, input: string)
            }
        }

        fileprivate func encode(to bitStream: inout WritableBitStream) {
            bitStream.appendEnum(valueTypeId)
            var success = false
            switch valueTypeId {
            case .int64:
                if let int64 = value as? Int64 {
                    bitStream.appendInt64(int64)
                    success = true
                }
            case .string:
                if let string = value as? String {
                    let (value, input) = NetworkData.networkMap(string)
                    bitStream.appendInt8(value)
                    bitStream.appendString(input)
                    success = true
                }
            }
            if !success {
                os_log(.error, log: GameLog.buildInfo,
                       "NetworkData.encode(): expected valueTypeId %s for value %s, but it is type %s",
                       "\(valueTypeId)", "\(value)", "\(type(of: value))")
            }
        }
    }

    // Make sure the keys used are minimized in length (and unique)
    // Length is important because this batch of data is stored as
    // binary through BitStreamCodable, and then converted
    // to base64 as a string for network transport in the multi-peer
    // connectivity code which as limits of 100-200 characters in he
    // discoveryInfo. log warnings will be generated for over 150 characters,
    // and an error will be generated for 200 characters
    static let base64CharacterWarning = 180
    static let base64CharacterError = 200
    private static let bundleSet: [(BuildInfo.Key, BuildInfo.Key?)] = [
        // Exposed via Settings bundle
        (.ciBuildNumber, .devBuildNumber),      // build version: either ciBuildNumber, or devBuildNumber
        (.devBuildNumber, .ciBuildNumber),      // build version: either devBuildNumber, or ciBuildNumber
        (.xcodeVersion, nil)                    // Xcodeversion
    ]

    //
    // for making sure that the host/server
    // build info match the client(s) during
    // the join process.  This info
    // comes from the BuildInfo.plist file
    // and any CI system can automate
    // updating the file for each build.
    //
    private(set) static var shared = BuildInfoNetworkBundle()

    static func update() {
        shared = BuildInfoNetworkBundle()
    }

    private var list = [BuildInfo.Key: NetworkData]()

    required init() {
        var required = [(BuildInfo.Key, BuildInfo.Key)]()
        var error = false
        BuildInfoNetworkBundle.bundleSet.forEach { (key, optional) in
            let entryValue = BuildInfo.getNetworkTypeForValue(forKey: key)
            let valueTypeId = key.asTypeId
            guard entryValue != nil || optional != nil else {
                fatalError(String(format: "BuildInfoNetworkBundle: key '%s' could not be converted to '%s'",
                                  "\(key.asString)",
                                  "\(valueTypeId)"))
            }
            if let value = entryValue {
                list[key] = NetworkData(valueTypeId: valueTypeId, value: value)
            } else {
                required.append((key, optional!))
            }
        }
        required.forEach { (key, optional) in
            if list[key] == nil && list[optional] == nil {
                os_log(.error, log: GameLog.buildInfo,
                       "require at least one of '%s' or '%s' in the BuildInfo.plist",
                       "\(key.asString)", "\(optional.asString)")
                error = true
            }
        }
        if error {
            fatalError("BuildInfoNetworkBundle: missing values in BuildInfo (see log)")
        }
    }

    // extension BuildInfoNetworkBundle: BitStreamCodable

    func encode(to bitStream: inout WritableBitStream) {
        let streamSize = bitStream.bytes.count
        bitStream.appendUInt32(UInt32(list.count))
        list.forEach { (key, data) in
            let size = bitStream.bytes.count
            key.encode(to: &bitStream)
            data.encode(to: &bitStream)
            os_log(.default, log: GameLog.networkConnect, "BuildInfo key: %s, data size %d", "\(key)", bitStream.bytes.count - size)
        }
        os_log(.default, log: GameLog.networkConnect, "BuildInfo encoded data size %d", bitStream.bytes.count - streamSize)
    }

    init(from bitStream: inout ReadableBitStream) throws {
        let count = Int(try bitStream.readUInt32())
        for _ in 0..<count {
            let key = try BuildInfo.Key(from: &bitStream)
            list[key] = try NetworkData(from: &bitStream)
        }
    }

    private func equalValues(ofTypeId networkTypeId: BuildInfoTypeId,
                             _ lhs: BuildInfoNetworkValueTypeProtocol?,
                             _ rhs: BuildInfoNetworkValueTypeProtocol?) -> Bool {
        switch networkTypeId {
        case .int64: return lhs as? Int64 == rhs as? Int64
        case .string: return lhs as? String == rhs as? String
        }
    }

    func compare() -> [String]? {
        var errors = [String]()
        var match = true
        let hostSettingsBundle = self
        let localSettingsBundle = BuildInfoNetworkBundle.shared
        if hostSettingsBundle.list.count != localSettingsBundle.list.count {
            errors.append(String(format: "local bundle (%d) != host bundle (%d)",
                                 localSettingsBundle.list.count,
                                 hostSettingsBundle.list.count))
            match = false
        }
        hostSettingsBundle.list.forEach { (key, data) in
            var errorString: String?
            let value = BuildInfo.getNetworkTypeForValue(forKey: key)
            if let localSettingsValue = value {
                if !equalValues(ofTypeId: data.valueTypeId, data.networkValue, localSettingsValue) {
                    errorString = String(format: "'%@'='%@', need '%@'",
                                         "\(key.asString)",
                                         "\(localSettingsValue)",
                                         "\(data.networkValue)")
                }
            } else {
                errorString = String( format: "host '%@' not in local build info", "\(key.asString)")
            }
            if let string = errorString {
                os_log(.default, log: GameLog.buildInfo, "BuildInfoNetworkBundle: compare %s", "\(string)")
                errors.append(string)
                match = false
            }
        }
        return match ? nil : errors
    }

}

extension BuildInfoNetworkBundle {
    private static func asBinary() -> Data? {
        var bits = WritableBitStream()
        shared.encode(to: &bits)
        let data = bits.finalize()
        return data
    }

    private static func fromBinary(data: Data) -> BuildInfoNetworkBundle? {
        let settingsBundle: BuildInfoNetworkBundle
        var bits = ReadableBitStream(data: data)
        do {
            settingsBundle = try BuildInfoNetworkBundle(from: &bits)
        } catch {
            return nil
        }
        return settingsBundle
    }

    static func asString() -> String {
        update()
        guard let binary = BuildInfoNetworkBundle.asBinary() else {
            return ""
        }
        os_log(.default, log: GameLog.buildInfo, "BuildInfoNetworkBundle binary size %d", binary.count)
        let string = binary.base64EncodedString()
        os_log(.default, log: GameLog.buildInfo, "BuildInfoNetworkBundle string size %d", string.count)

        if string.count > base64CharacterError {
            os_log(.error, log: GameLog.buildInfo,
                   "BuildInfoNetworkBundle string size over %d, which is the limit indicated in documentation",
                   base64CharacterError)
        } else if string.count > base64CharacterWarning {
            os_log(.error, log: GameLog.buildInfo,
                   "BuildInfoNetworkBundle string size over %d, which is getting close to the limit(%d) indicated in documentation",
                   base64CharacterWarning,
                   base64CharacterError)
        }
        return string
    }

    static func fromString(base64String: String) -> BuildInfoNetworkBundle? {
        guard let binary = Data(base64Encoded: base64String) else {
            os_log(.error, log: GameLog.buildInfo, "failed getting build info bundle base64 data string '%s'", "\(base64String)")
            return nil
        }
        guard let buildInfoBundle = BuildInfoNetworkBundle.fromBinary(data: binary) else {
            os_log(.error, log: GameLog.buildInfo, "failed getting build info bundle from binary data from string '%s'", "\(base64String)")
            return nil
        }
        return buildInfoBundle
    }
}

extension BuildInfoNetworkBundle {
    static func logErrors(_ errors: [String]) {
        os_log(.error, log: GameLog.networkConnect, "BuildInfoNetworkBundle: local build info doesn't match host build info:")
        errors.forEach { error in
            os_log(.default, log: GameLog.networkConnect, "BuildInfoNetworkBundle:    %s", "\(error)")
        }
    }
}
